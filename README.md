
# Mappings between F# Seq and LINQ

This is an attempt do build an exhaustive list of mappings between
LINQ's extension methods on `IEnumerable<T>` and F# sequence manipulation
functions, in order to ease the transition for C# devs.

The current list is absolutely **NOT** complete. Running the
unit tests will tell you which mappings are missing, so please
contribute!

|LINQ methods|F# Seq functions|Explanation|
|---|---|---|
|**Aggregate**|**reduce**|Aggregates, reduces or folds (as you prefer) a sequence of items to a single value. The output type is the same as the type of the elements of the sequence, and it will fail on an empty sequence.<br><br>**Aggregate** in LINQ<br>Ex: `(new[] {1, 2, 3}).Aggregate((x, y) => x + y)`<br><br>becomes in F#:<br>**reduce**: `(T -> T -> T) -> seq<T> -> T`<br>Ex: `[1; 2; 3] |> Seq.reduce (+)`|
|**Aggregate**|**fold**|Aggregates, reduces or folds (as you prefer) a sequence of items to a single value. Using fold, you can provide an initial value for the accumulator, and the result will be of the type of the accumulator.<br><br>**Aggregate** in LINQ<br>Ex: `(new[] {1, 2, 3}).Aggregate("", (x, y) => x + y)`<br><br>becomes in F#:<br>**fold**: `(TState -> T -> TState) -> TState -> seq<T> -> TState`<br>Ex: `[1; 2; 3] |> Seq.fold (sprintf "%s%i") ""`|
|**All**|**forall**|Evaluates whether a given predicate is true for all the elements of the sequence.<br><br>**All** in LINQ<br>Ex: `(new[] {1, 2, 3}).All(i => i % 2 == 0)`<br><br>becomes in F#:<br>**forall**: `(T -> bool) -> seq<T> -> bool`<br>Ex: `[1; 2; 3] |> Seq.forall (fun i -> i % 2 = 0)`|
|**Any**|**exists**|Evaluates whether there exists an element in the sequence for which the predicate is true.<br><br>**Any** in LINQ<br>Ex: `(new[] {1, 2, 3}).Any(i => i % 2 == 0)`<br><br>becomes in F#:<br>**exists**: `(T -> bool) -> seq<T> -> bool`<br>Ex: `[1; 2; 3] |> Seq.exists (fun i -> i % 2 = 0)`|
|**AsEnumerable**||`AsEnumerable` is mostly used in C# to hide the actual type of the enumerable implementation (either a concrete type such as `List<T>` or another interface such as `ICollection<T>` or `IQueryable<T>`). It could be replaced by a cast to `IEnumerable<T>`, but that doesn't play well with chaining of extensions methods (fluent style). In F#, we don't really care, as we use piping most of the time. Alternatively, you could also use `Seq.ofList` or `Seq.ofArray`, depending on your input type.<br><br>**AsEnumerable** in LINQ<br>Ex: `(new[] {1, 2, 3}).AsEnumerable()`<br><br>becomes in F#:<br>Ex: `[1; 2; 3] :> seq<_>`|
|**Average**|**average**|Computes the average value of the items. `Seq.average` doesn't take any other argument than the input sequence. If the items in the sequence need to be projected to a value before computing the average, `Seq.averageBy` must be used.<br><br>**Average** in LINQ<br>Ex: `(new[] {1.0, 2.0, 3.0}).Average()`<br><br>becomes in F#:<br>**average**: `seq<T> -> T`<br>Ex: `[1.0; 2.0; 3.0] |> Seq.average`|
|**Average**|**averageBy**|Computes the average of the values projected from the items in the sequence with the provided projection function. It is semantically equivalent to `fun f -> Seq.map f >> Seq.average`.<br><br>**Average** in LINQ<br>Ex: `(new[] {"a", "bb", "ccc"}).Average(s => s.Length)`<br><br>becomes in F#:<br>**averageBy**: `(T -> TResult) -> seq<T> -> TResult`<br>Ex: `["a"; "bb"; "ccc"] |> Seq.averageBy (fun s -> float s.Length)`|
|**Cast**|**cast**|Casts (either up or down) a sequence of one type to a sequence of another type.<br><br>**Cast** in LINQ<br>Ex: `(new object[] {1, 2, 3}).Cast<int>()`<br><br>becomes in F#:<br>**cast**: `IEnumerable -> seq<T>`<br>Ex: `[1 :> obj; 2 :> obj; 3 :> obj] |> Seq.cast<int>`|
|**Concat**|**append**|Wraps the two given enumerations as a single concatenated enumeration.<br><br>**Concat** in LINQ<br>Ex: `(new[] {1, 2, 3}).Concat(new[] {4, 5, 6})`<br><br>becomes in F#:<br>**append**: `seq<T> -> seq<T> -> seq<T>`<br>Ex: `Seq.append [1; 2; 3] [4; 5; 6]`|
|**Contains**|**contains**|Checks whether a sequence contains the given element.<br><br>**Contains** in LINQ<br>Ex: `(new[] {1, 2, 3}).Contains(2)`<br><br>becomes in F#:<br>**contains**: `T -> seq<T> -> bool`<br>Ex: `[1; 2; 3] |> Seq.contains 2`|
|**Count**|**length**|Evaluates to the length of the sequence.<br><br>**Count** in LINQ<br>Ex: `(new[] {1, 2, 3}).Count())`<br><br>becomes in F#:<br>**length**: `seq<T> -> Int32`<br>Ex: `[1; 2; 3] |> Seq.length`|
|**DefaultIfEmpty**||Seriously? Who uses that method?<br><br>**DefaultIfEmpty** in LINQ<br>Ex: `(new int[] {}).DefaultIfEmpty(2)`<br><br>becomes in F#:<br>Ex: `[] |> fun s -> if Seq.isEmpty s then [2] else s`|
|**Select**|**map**|Maps every element of the input sequence to an element in the output sequence using the provided mapping function.<br><br>**Select** in LINQ<br>Ex: `(new[] {1, 2, 3}).Select(i => i * 2)`<br><br>becomes in F#:<br>**map**: `(T -> TResult) -> seq<T> -> seq<TResult>`<br>Ex: `[1; 2; 3] |> Seq.map (fun i -> i * 2)`|
|**SelectMany**|**collect**|For each element of the input sequence, use the provided generator function to generate a sequence and elements, and collect all the generated elements into a single sequence. `Seq.collect f` is semantically equivalent to `Seq.map f >> Seq.concat`.<br><br>**SelectMany** in LINQ<br>Ex: `(new[] {1, 2, 3}).SelectMany(i => Enumerable.Range(0, i))`<br><br>becomes in F#:<br>**collect**: `(T -> TCollection) -> seq<T> -> seq<TResult>`<br>Ex: `[1; 2; 3] |> Seq.collect (fun i -> Seq.init i id)`|
|**SelectMany**|**concat**|Concatenates a sequence of sequences into a single sequence. `Seq.concat` is semantically equivalent to `Seq.collect id`.<br><br>**SelectMany** in LINQ<br>Ex: `(new[] {(new[] {1, 2, 3}), (new[] {4, 5, 6}), (new[] {7})}).SelectMany(x => x)`<br><br>becomes in F#:<br>**concat**: `seq<TCollection> -> seq<T>`<br>Ex: `[[1; 2; 3]; [4; 5; 6]; [7]] |> Seq.concat`|
|**Where**|**where**|Returns a filtered sequence containing only the elements of the input sequence which satisfy the provided predicate. Alternatively `Seq.filter` can also be used and does exactly the same.<br><br>**Where** in LINQ<br>Ex: `(new[] {1, 2, 3}).Where(x > 2)`<br><br>becomes in F#:<br>**where**: `(T -> bool) -> seq<T> -> seq<T>`<br>Ex: `[1; 2; 3] |> Seq.where (fun x -> x > 2)`|
|**Zip**|**zip**|Zips two sequences by creating a sequence of tuples of elements taken from both seuqences. The LINQ version alays requires a function to project the two items taken from both sequences. In that particular case, projecting with `Tuple.Create` will  do the same as the F# `zip` function.<br><br>**Zip** in LINQ<br>Ex: `(new[] { 1, 2, 3 }).Zip((new[] { 4, 5, 6 }), Tuple.Create)`<br><br>becomes in F#:<br>**zip**: `seq<T1> -> seq<T2> -> seq<Tuple`2>`<br>Ex: `Seq.zip [1; 2; 3] [4; 5; 6]`|
|**Zip**|**map2**|The LINQ version of `Zip` takes an argument to project the result from the items taken in both sequences. The F# equivalent of this is a `map2`.<br><br>**Zip** in LINQ<br>Ex: `(new[] { 1, 2, 3 }).Zip((new[] { 4, 5, 6 }), (x, y) => x * y)`<br><br>becomes in F#:<br>**map2**: `(T1 -> T2 -> TResult) -> seq<T1> -> seq<T2> -> seq<TResult>`<br>Ex: `([1; 2; 3], [4; 5; 6]) ||> Seq.map2 (*)`|
